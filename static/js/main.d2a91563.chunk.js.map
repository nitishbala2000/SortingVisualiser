{"version":3,"sources":["components/Header/Header.js","components/SortingForm/SortingForm.js","components/Bars/Bars.js","components/StopSortingButton/StopSortingButton.js","helper_functions.js","App.js","index.js"],"names":["Header","className","href","getBubbleSortContent","getMergeSortContent","getQuickSortContent","getHeapSortContent","SortingForm","props","modalTitle","modalContent","algorithm","getModalTitleAndContent","type","disabled","sorting","min","max","value","arrayLen","toString","onChange","changeArrayLen","algorithmChanged","onClick","regenArray","sort","data-toggle","data-target","id","tabindex","role","aria-labelledby","aria-hidden","data-dismiss","aria-label","Bars","bars","i","array","n","push","style","height","width","marginRight","backgroundColor","colors","StopSortingButton","textAlign","marginTop","class","stopSorting","merge","arr1","arr2","ptr1","ptr2","output","length","slice","flatten","arr","subArray","swap","j","newArr","temp","App","state","sortingIntervalVar","clearInterval","newColors","setState","resetArray","newArray","Math","round","random","event","target","bubbleSort","swapsMade","intervalVar","setInterval","mergeSort","arraysToMerge","lengthsInThisIteration","startIndex","splice","endIndex1","endIndex2","partition","low","high","callback","pivot","incrementJ","arrCopy","getNewColors","pivotColor","ijColor","quickSortHelper","splitpoint","quickSort","heapify","setTimeout","largest","l","r","heapSortHeapifyLoop","heapSortMainLoop","heapSort","iInitial","floor","this","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d2a91563.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\n\r\nconst Header = () => (\r\n    <nav className=\"navbar navbar-dark bg-dark\">\r\n        <a className=\"navbar-brand\" href=\"#\">Sorting visualiser</a>\r\n    </nav>\r\n);\r\n\r\n\r\n\r\nexport default Header;","import React from \"react\";\r\nimport \"./SortingForm.css\";\r\n\r\n\r\nconst getModalTitleAndContent = (algorithm) => {\r\n    switch (algorithm) {\r\n        case \"bubble\":\r\n            return [\"Bubble Sort\", getBubbleSortContent()];\r\n        case \"merge\":\r\n            return [\"Merge Sort\", getMergeSortContent()];\r\n        case \"quick\":\r\n            return [\"Quick Sort\", getQuickSortContent()];\r\n        case \"heap\":\r\n            return [\"Heap Sort\", getHeapSortContent()];\r\n        default:\r\n            return [];\r\n    }\r\n}\r\n\r\n\r\nconst getBubbleSortContent = () => (\r\n    <div>\r\n        <p>Bubble Sort works by repeatedly iterating through the array comparing adjacent elements in the array and swapping them\r\n        if needed. The algorithm finishes when an entire pass has been made without having to swap any elements.\r\n        </p>\r\n\r\n        <p>\r\n            See <a href=\"https://www.geeksforgeeks.org/bubble-sort/\">here</a> for pseudocode.\r\n        </p>\r\n  \r\n        <p>\r\n            Key:\r\n            <ul>\r\n                <li>The green/red bars represent the current items being compared. If the bars are red, they are to be swapped</li>\r\n            </ul>\r\n        </p>\r\n      \r\n    </div>\r\n)\r\n\r\nconst getMergeSortContent = () => (\r\n    <div>\r\n        <p>\r\n            Merge Sort works by splitting the list into two, recursively sorting each sublist and <strong>merging</strong> the\r\n            two sorted sublists together. It is one of the fastest sorting algorithm\r\n        </p>\r\n\r\n        <p>\r\n            See <a href=\"https://www.geeksforgeeks.org/merge-sort/\">here</a> for pseudocode.\r\n        </p>\r\n\r\n        <p>\r\n            Key:\r\n            <ul>\r\n                <li>The algorithm implemented below is actually <strong>bottom-up merge sort</strong>, which is not recursive, but a similar idea</li>\r\n                <li>The green and red bars show the current sublist being merged. As you see, these sublists get bigger and bigger, and\r\n                in the final iteration, the sublists cover the entire list\r\n                </li>\r\n            </ul>\r\n        </p>\r\n   \r\n    </div>\r\n);\r\n\r\nconst getQuickSortContent = () => (\r\n    <div>\r\n        <p>\r\n            Quick sort works by choosing the last item of the list as a <strong>pivot</strong> (note - alternative implementations exist,\r\n            such as using the first / middle item). It finds all elements less than the pivot, and all elements greater than the pivot. It\r\n            then recursively sorts each partition, inserting the pvot in between\r\n        </p>\r\n\r\n        <p>\r\n            See <a href=\"https://www.geeksforgeeks.org/quick-sort/\">here</a> for pseudocode.\r\n        </p>\r\n\r\n        <p>\r\n            Key:\r\n            <ul>\r\n                <li>The algorithm implemented below is <strong>in-place</strong> quick sort, which is more space efficient than the obvious recursive solution</li>\r\n                <li>The yellow bar shows the current pivot. If you inspect the pseudocode, when finding the splitpoint, there is a left pointer and a right pointer,\r\n                    represented by green bars. When swaps are made, these bard turn red\r\n                </li>\r\n            </ul>\r\n        </p>\r\n\r\n    </div>\r\n);\r\n\r\nconst getHeapSortContent = () => (\r\n    <div>\r\n        <p>\r\n            Heap sort meakes use of a structure called a <strong>binary maxheap</strong>. A binary heap is a tree-like structure where\r\n            each item has two children, and every item must be greater than or equal to all of its children. Furthermore, every element\r\n            is greater than or equal to all nodes to the right on the samle level. The typical implementation\r\n            is to use an array, where for an item at index i, the left child is stored at index 2i + 1 and the right child is stored at\r\n            2i + 2\r\n        </p>\r\n\r\n        <p>\r\n            Heap sort consists of two stages:\r\n            <ol>\r\n                <li>\r\n                    Converting the input array into a binary heap. This is a simple recursive procedure that is applied\r\n                    to all non-leaf nodes - see the pseudocode below\r\n                </li>\r\n                <li>\r\n                    Repeatedly taking the last elements of the array (the leaves of the heap, which we know are the smallest elements) and putting\r\n                    them at the front where they belong. Then recreating the heap structure accordingly\r\n                </li>\r\n            </ol>\r\n        </p>\r\n\r\n        <p>\r\n            See <a href=\"https://www.geeksforgeeks.org/heap-sort/\">here</a> for pseudocode.\r\n        </p>\r\n\r\n        <p>\r\n            Key:\r\n            <ul>\r\n                <li>The yellow bar shows the element currently being placed in the array to form a heap</li>\r\n                <li>The green bar shows the yellow bars largest child, which it is about to be swapped with</li>\r\n                <li>The red bars are used to animate the second stage of the algorithm - they show the bars at index \"i\" (which is the smallest item)\r\n                    and index 0 in the loop defined in teh pseudocode\r\n                </li>\r\n            </ul>\r\n        </p>\r\n\r\n    </div>\r\n);\r\n\r\n\r\n\r\nconst SortingForm = (props) => {\r\n\r\n    let modalTitle, modalContent;\r\n    [modalTitle, modalContent] = getModalTitleAndContent(props.algorithm);\r\n\r\n    return (\r\n\r\n        <div className=\"SortingForm\">\r\n\r\n            <p>\r\n                <label>Choose Array Size: </label>\r\n                <input type=\"range\" disabled={props.sorting} min=\"0\" max=\"50\" value={props.arrayLen.toString()} onChange={props.changeArrayLen} />\r\n            </p>\r\n\r\n            <p>\r\n                <label>Choose your sorting algorithm: </label>\r\n                <select disabled={props.sorting} onChange={props.algorithmChanged} value={props.algorithm}>\r\n                    <option value=\"bubble\">Bubble Sort</option>\r\n                    <option value=\"merge\">Merge Sort</option>\r\n                    <option value=\"quick\">Quick Sort</option>\r\n                    <option value=\"heap\">Heap Sort</option>\r\n                </select>\r\n            </p>\r\n\r\n\r\n            <button disabled={props.sorting} type=\"button\" className=\"btn btn-outline-info\" onClick={props.regenArray}>Regenerte array</button>\r\n            <button disabled={props.sorting} type=\"button\" className=\"btn btn-outline-info\" onClick={props.sort}>Sort!</button>\r\n            <button type=\"button\" className=\"btn btn-outline-info\" data-toggle=\"modal\" data-target=\"#helpModal\">Help</button>\r\n\r\n\r\n            <div className=\"modal fade\" id=\"helpModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalCenterTitle\" aria-hidden=\"true\">\r\n                <div className=\"modal-dialog modal-dialog-centered\" role=\"document\">\r\n                    <div className=\"modal-content\">\r\n                        <div className=\"modal-header\">\r\n                            <h5 className=\"modal-title\">{modalTitle}</h5>\r\n                            <button type=\"button\" className=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\r\n                                <span aria-hidden=\"true\">&times;</span>\r\n                            </button>\r\n                        </div>\r\n                        <div className=\"modal-body text-left\">\r\n                            {modalContent}\r\n                        </div>\r\n\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n        </div>\r\n    )\r\n\r\n\r\n};\r\n\r\nexport default SortingForm;","import \"./Bars.css\";\r\nimport React from \"react\";\r\n\r\nconst Bars = (props) => {\r\n\r\n    const bars = [];\r\n    for (let i in props.array) {\r\n        let n = props.array[i];\r\n        bars.push(\r\n            <div style={{\r\n                height: n * 4 + \"px\",\r\n                width: \"50px\",\r\n                marginRight: \"5px\",\r\n                backgroundColor: props.colors[i]\r\n            }}/>\r\n        )\r\n    }\r\n    \r\n\r\n    return (\r\n        <div className=\"container\">\r\n            {bars}\r\n        </div>\r\n    )\r\n\r\n}\r\n\r\nexport default Bars;","import React from \"react\";\r\n\r\nconst StopSortingButton = (props) => {\r\n    return (\r\n        <p style={{textAlign : \"center\", marginTop: \"20px\"}}>\r\n            <button type=\"button\" class=\"btn btn-outline-info\" onClick={props.stopSorting}>Stop</button>\r\n        </p>\r\n    )\r\n}\r\n\r\nexport default StopSortingButton;","\r\nexport const merge = (arr1, arr2) => {\r\n    let ptr1 = 0, ptr2 = 0;\r\n    let output = [];\r\n    while (ptr1 < arr1.length && ptr2 < arr2.length) {\r\n        if (arr1[ptr1] < arr2[ptr2]) {\r\n            output.push(arr1[ptr1]);\r\n            ptr1 ++;\r\n        } else {\r\n            output.push((arr2[ptr2]));\r\n            ptr2 ++;\r\n        }\r\n    }\r\n\r\n    if (ptr1 == arr1.length) {\r\n        output.push(...arr2.slice(ptr2));\r\n    } else {\r\n        output.push(...arr1.slice(ptr1));\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\nexport const flatten = (arr) => {\r\n    let output = [];\r\n    for (let subArray of arr) {\r\n        output.push(...subArray);\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\nexport const swap = (arr, i, j) => {\r\n    const newArr = [...arr];\r\n    let temp = newArr[i];\r\n    newArr[i] = newArr[j];\r\n    newArr[j] = temp;\r\n    return newArr;\r\n}","import React, { Component } from 'react';\nimport Header from \"./components/Header/Header\";\nimport SortingForm from './components/SortingForm/SortingForm';\nimport Bars from \"./components/Bars/Bars\";\nimport StopSortingButton from \"./components/StopSortingButton/StopSortingButton\";\nimport { merge, flatten, swap } from \"./helper_functions\";\n\nconst colors = {\n  BLUE: \"#6399F1\",\n  GREEN: \"#6CDB7B\",\n  RED: \"#DD5C5C\",\n  PURPLE: \"#B578E8\",\n  YELLOW: \"yellow\"\n}\n\n\n\nclass App extends Component {\n\n  state = {\n    algorithm: \"merge\",\n    array: [],\n    colors: [],\n    sorting: false,\n    sortingIntervalVar: null\n  }\n\n  componentDidMount() {\n    this.resetArray(10);\n  }\n\n  stopSorting = () => {\n    clearInterval(this.state.sortingIntervalVar);\n    const newColors = [];\n    for (let n in this.state.array) {\n      newColors.push(colors.PURPLE);\n    }\n\n    this.setState({ sorting: false, colors: newColors });\n  }\n\n\n\n  resetArray = (n) => {\n    const newArray = [];\n    const newColors = [];\n    for (let i = 0; i < n; i++) {\n      newArray.push(Math.round(Math.random() * 100));\n      newColors.push(colors.BLUE);\n    }\n\n    this.setState({ array: newArray, colors: newColors });\n  }\n\n\n  algorithmChanged = (event) => {\n    this.setState({ algorithm: event.target.value });\n    this.resetArray(this.state.array.length);\n  }\n\n\n  bubbleSort = () => {\n\n    let i = 0;\n    let swapsMade = false;\n\n    let intervalVar = setInterval(() => {\n      if (this.state.array[i] > this.state.array[i + 1]) {\n\n        let newArray = swap(this.state.array, i, i + 1);\n\n        let newColors = [];\n        for (let j in this.state.array) {\n          if (j == i || j == i + 1) {\n            newColors[j] = colors.RED;\n          } else {\n            newColors[j] = colors.BLUE;\n          }\n        }\n\n\n        this.setState({ array: newArray, colors: newColors }, () => {\n\n\n          if (i == this.state.array.length - 2) {\n            i = 0;\n            swapsMade = false;\n          } else {\n            i++;\n            swapsMade = true;\n          }\n\n        });\n\n      } else {\n\n\n        let newColors = [];\n        for (let j in this.state.array) {\n          if (j == i || j == i + 1) {\n            newColors[j] = colors.GREEN;\n          } else {\n            newColors[j] = colors.BLUE;\n          }\n        }\n\n        this.setState({ colors: newColors }, () => {\n\n\n          if (i == this.state.array.length - 2) {\n            if (!swapsMade) {\n\n              this.stopSorting();\n\n            } else {\n              i = 0;\n              swapsMade = false;\n            }\n\n          } else {\n            i++;\n          }\n\n        });\n\n      }\n\n    }, 100);\n\n    this.setState({ sortingIntervalVar: intervalVar });\n\n  }\n\n  mergeSort = () => {\n\n    let arraysToMerge = [];\n    for (let i of this.state.array) {\n      arraysToMerge.push([i]);\n    }\n\n    let i = 0;\n\n    let lengthsInThisIteration = 1;\n    let startIndex = 0;\n\n    let intervalVar = setInterval(() => {\n      if (arraysToMerge.length == 1) {\n        //Sorting finished\n        this.setState({ array: arraysToMerge[0] }, this.stopSorting);\n\n      } else {\n\n        let arr1, arr2;\n        [arr1, arr2] = arraysToMerge.splice(i, 2);\n\n        let endIndex1 = startIndex + lengthsInThisIteration;\n        let endIndex2 = startIndex + lengthsInThisIteration * 2;\n\n\n        arraysToMerge.splice(i, 0, merge(arr1, arr2));\n\n        const newColors = [];\n        for (let j in this.state.colors) {\n          if (j >= startIndex && j < endIndex1) {\n            newColors[j] = colors.GREEN;\n          } else if (j >= endIndex1 && j < endIndex2) {\n            newColors[j] = colors.RED;\n          } else {\n            newColors[j] = colors.BLUE;\n          }\n        }\n\n\n\n        this.setState({ array: flatten(arraysToMerge), colors: newColors }, () => {\n          i++;\n          startIndex = endIndex2;\n          if (i >= arraysToMerge.length - 1) {\n            i = 0;\n            lengthsInThisIteration *= 2;\n            startIndex = 0;\n          }\n\n        });\n      }\n    }, 100);\n\n    this.setState({ sortingIntervalVar: intervalVar });\n\n  }\n\n  partition = (low, high, callback) => {\n    let i = low - 1;\n    let pivot = this.state.array[high];\n    let j = low;\n    let intervalVar = null;\n\n    let incrementJ = () => {\n      j++;\n      if (j == high) {\n\n        let arrCopy = swap(this.state.array, i + 1, high);\n\n        const newColors = [];\n\n        for (let n in this.state.colors) {\n          if (n == i + 1 || n == high) {\n            newColors.push(colors.GREEN);\n          } else {\n            newColors.push(colors.BLUE);\n          }\n        }\n\n        this.setState({ array: arrCopy, colors: newColors }, () => {\n          //This iteration of partition has finished\n          clearInterval(intervalVar);\n          callback(i + 1);\n        })\n      }\n\n    };\n\n    const getNewColors = (pivotColor, ijColor) => {\n      const newColors = [];\n      for (let n in this.state.array) {\n        if (n == high) {\n          newColors.push(pivotColor);\n        } else if (n == i || n == j) {\n          newColors.push(ijColor);\n        } else {\n          newColors.push(colors.BLUE);\n        }\n      }\n\n      return newColors;\n    }\n\n    intervalVar = setInterval(() => {\n      if (this.state.array[j] <= pivot) {\n        i++;\n\n        let arrCopy = swap(this.state.array, i, j);\n        const newColors = getNewColors(colors.YELLOW, colors.RED);\n\n        this.setState({ array: arrCopy, colors: newColors }, () => {\n          incrementJ();\n        });\n\n      } else {\n\n        const newColors = getNewColors(colors.YELLOW, colors.GREEN);\n\n        this.setState({ colors: newColors }, () => {\n          incrementJ();\n        });\n      }\n    }, 100);\n\n    this.setState({ sortingIntervalVar: intervalVar });\n    \n  }\n\n  quickSortHelper = (low, high, callback) => {\n    if (low < high) {\n      this.partition(low, high, (splitpoint) => {\n        this.quickSortHelper(low, splitpoint - 1, () => {\n          this.quickSortHelper(splitpoint + 1, high, () => {\n            callback();\n          });\n        });\n\n      })\n    } else {\n      callback();\n    }\n\n  }\n\n  quickSort = () => {\n    this.quickSortHelper(0, this.state.array.length - 1, this.stopSorting);\n  }\n\n\n  heapify = (n, i, callback) => {\n    if (!this.state.sorting) {\n      return;\n    }\n\n    setTimeout(() => {\n      let largest = i;\n\n      let l = 2 * i + 1;\n      let r = 2 * i + 2;\n\n      if (l < n && this.state.array[i] < this.state.array[l]) {\n        largest = l;\n      }\n\n\n      if (r < n && this.state.array[largest] < this.state.array[r]) {\n        largest = r;\n      }\n\n      if (largest != i) {\n        const arrCopy = swap(this.state.array, largest, i);\n\n        let newColors = [];\n        for (let j in this.state.colors) {\n          if (j == i) {\n            newColors.push(colors.YELLOW);\n          } else if (j == largest) {\n            newColors.push(colors.GREEN);\n          } else {\n            newColors.push(colors.BLUE);\n          }\n        }\n\n        this.setState({ array: arrCopy, colors: newColors }, () => {\n          this.heapify(n, largest, callback);\n        });\n\n      } else {\n\n\n        if (callback) {\n          callback();\n        }\n      }\n\n    }, 100);\n  }\n\n  heapSortHeapifyLoop = (i, callback) => {\n    const n = this.state.array.length;\n    this.heapify(n, i, () => {\n      if (i == 0) {\n        callback();\n      } else {\n        this.heapSortHeapifyLoop(i - 1, callback);\n      }\n    })\n\n  }\n\n  heapSortMainLoop = (i, callback) => {\n\n    const newArr = swap(this.state.array, i, 0);\n\n    const newColors = [];\n    for (let j in this.state.colors) {\n      if (j == i || j == 0) {\n        newColors.push(colors.RED);\n      } else {\n        newColors.push(colors.BLUE);\n      }\n    }\n    this.setState({ array: newArr, colors: newColors }, () => {\n      this.heapify(i, 0, () => {\n        if (i > 1) {\n          this.heapSortMainLoop(i - 1, callback);\n        } else {\n          callback();\n        }\n      })\n    })\n\n\n  }\n\n  heapSort = () => {\n    const n = this.state.array.length;\n    const iInitial = Math.floor(n / 2) - 1;\n\n    this.heapSortHeapifyLoop(iInitial, () => {\n      this.heapSortMainLoop(n - 1, this.stopSorting);\n    });\n  }\n\n  sort = () => {\n\n    switch (this.state.algorithm) {\n      case \"bubble\": {\n        this.setState({ sorting: true }, () => this.bubbleSort());\n        break;\n      } case \"merge\": {\n        this.setState({ sorting: true }, () => this.mergeSort());\n        break;\n      } case \"quick\": {\n        this.setState({ sorting: true }, () => this.quickSort());\n        break;\n      } case \"heap\": {\n        this.setState({ sorting: true }, () => this.heapSort());\n        break;\n      }\n    }\n\n  }\n\n\n\n  render() {\n\n\n    return (\n      <div className=\"App\">\n\n        <Header />\n        <SortingForm\n          arrayLen={this.state.array.length}\n          algorithm={this.state.algorithm}\n          changeArrayLen={(event) => this.resetArray(event.target.value)}\n          algorithmChanged={this.algorithmChanged}\n          regenArray={() => this.resetArray(this.state.array.length)}\n          sort={this.sort}\n          sorting={this.state.sorting} />\n\n        <Bars array={this.state.array} colors={this.state.colors}></Bars>\n\n        {this.state.sorting ? <StopSortingButton stopSorting={this.stopSorting} /> : null}\n\n      </div>\n    )\n  };\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport {merge, flatten} from \"./helper_functions\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}